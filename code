#include <AccelStepper.h>

//defines pins numbers
AccelStepper lMotor(1, 3, 2 ); //left
const int Lms1 = 33;
const int Lms2 = 35;
const int Lms3 = 37;

AccelStepper rMotor(1,13,12); //right
const int Rms1 = 32;
const int Rms2 = 34;
const int Rms3 = 36;

const int grid_Motor = 7;
const int buttonPin = 28;

int currentstep = 1;

int stop = 0; //1 is stop

int frequency = 0;
const int black_value = 20;
#define S0 23  // light sensor, TCS3200
#define S1 25
#define S2 24
#define S3 26
#define out 22

const float TRACK_WIDTH = 1000.0 ; //mm, distance from the center of the wheels
const float WHEEL_DIAMETER = 88.0; // mm
const float WHEEL_CIRCUMFERENCE = 3.14159 * WHEEL_DIAMETER; // ~276.46 mm
const int STEPS_PER_REV = 200;
const float STEPS_FOR_90_TURN = WHEEL_DIAMETER * STEPS_PER_REV / 4.0 / TRACK_WIDTH;


long l_dl(){
  return lMotor.distanceToGo();
}

long r_dl(){
  return rMotor.distanceToGo();
}

// Calculate steps for movements
int stepsForDistance(float distance_mm) {
  Serial.println((distance_mm / WHEEL_CIRCUMFERENCE) * STEPS_PER_REV);
  return (int)((distance_mm / WHEEL_CIRCUMFERENCE) * STEPS_PER_REV);
}

void setup() {
 lMotor.setMaxSpeed(1500);
 rMotor.setMaxSpeed(1500);

 lMotor.setAcceleration(800);
 rMotor.setAcceleration(800);
  pinMode(Lms1, OUTPUT);
  pinMode(Lms2, OUTPUT);
  pinMode(Lms3, OUTPUT);
  pinMode(Rms1, OUTPUT);
  pinMode(Rms2, OUTPUT);
  pinMode(Rms3, OUTPUT);

  pinMode(S0, OUTPUT);
  pinMode(S1, OUTPUT);
  pinMode(S2, OUTPUT);
  pinMode(S3, OUTPUT);
  pinMode(out, INPUT);

  
  
  Serial.begin(9600); 

  pinMode(buttonPin, INPUT);
}

void DBUG(char msg){
  
  Serial.println(msg);
}

void detect_black_line(){

  digitalWrite(S2,HIGH); //clear, no filter
  digitalWrite(S3,LOW);
  digitalWrite(S0,HIGH); // Frequency scaling to 20%
  digitalWrite(S1,LOW);

  Serial.print("Freq: ");
  Serial.println(frequency);
  
  frequency = pulseIn(out, LOW);
  
  if(frequency > black_value){
    Serial.println("Black Line Detected");
    // Add motor control code here
  } else {
    Serial.println("White Surface");
  }
  
  delay(100);
}



void go(float distance){
  int steps = stepsForDistance(distance);
  rMotor.move(steps);
  lMotor.move(steps);

}
 
void Lower_grid (){
digitalWrite(grid_Motor, HIGH);
delay(100);
digitalWrite(grid_Motor, LOW);
}

void Raise_grid (){
digitalWrite(grid_Motor, HIGH);
delay(100);
digitalWrite(grid_Motor, LOW);
}



void loop() {
  lMotor.run();
  rMotor.run();

  if (digitalRead(buttonPin) == LOW){
    lMotor.stop();
    rMotor.stop();
    stop = 1;
  }
  if (l_dl == 0 && r_dl == 0 && stop != 1){


  }
   

}

